// app/chat/page.tsx
'use client';

import { useState, useEffect, useRef, useMemo } from 'react';
import { useSession } from 'next-auth/react';
// Import your custom typed useZero hook from your client.tsx
import { useZero } from '@/lib/zero/zero';
// Import useQuery from @rocicorp/zero/react
import { useQuery } from '@rocicorp/zero/react';
// Import your Schema type (Schema from Zero's perspective, generated by drizzle-zero)
import { type Schema } from '@/lib/zero/config';
// Import your CustomUser type for session data
import { CustomUser } from '@/lib/auth';
// Import your loader component
import LinesLoader from '@/components/linesLoader'; // Assuming this path is correct


// --- UI and Data Types ---

interface ChatEvent {
  id: string;
  name: string | null;
  createdAt: string; // Assuming string from API, convert to Date if needed
}

// This is the type for messages displayed in the UI, enriched with username
interface MessageForUI {
  id: string;
  userId: string;
  username: string; // Populated by joining with users data
  eventId: string;
  text: string;
  replyToMessageId: string | null;
  isDeleted: boolean;
  createdAt: number; // Timestamp (number) as stored in Zero
}

// This type should match the structure of a message row in your Zero schema
// (as defined by zero-schema.gen.ts for the 'messages' table)
interface RawZeroMessage {
  id: string;
  userId: string;
  eventId: string;
  text: string;
  replyToMessageId: string | null;
  isDeleted: boolean;
  createdAt: number;
  // Add other fields if they exist in your Zero 'messages' table schema
  // e.g., deletedAt?: number | null; deletedByUserId?: string | null;
}

// This type should match the structure of a user row in your Zero schema
// (as defined by zero-schema.gen.ts for the 'users' table)
interface RawZeroUser {
  id: string;
  username: string; // Make sure 'username' is synced by drizzle-zero for users table
  name?: string | null; // 'name' from Drizzle (maps to displayName)
  role?: string | null;
  image?: string | null; // 'image' from Drizzle (avatar_url)
}


export default function ChatPage() {
  const { data: session, status: authStatus } = useSession();
  const z = useZero(); // Your typed Zero instance from createUseZero<Schema, AppMutators>()
  const [currentEvent, setCurrentEvent] = useState<ChatEvent | null>(null);
  const [newMessageText, setNewMessageText] = useState('');
  const [isSending, setIsSending] = useState(false);
  const [replyToId, setReplyToId] = useState<string | null>(null);

  const messagesEndRef = useRef<HTMLDivElement>(null);

  const isZeroInstanceReady = !!z; // True if Zero instance is created and provided by useZero

  // --- Fetch Current Active Event ---
  useEffect(() => {
    if (authStatus === 'authenticated') {
      fetch('/api/chat/active')
        .then(res => {
          if (!res.ok) {
            return res.json().catch(() => ({ message: `HTTP error ${res.status}` }))
              .then((errBody: { message?: string }) => { throw new Error(errBody.message || `Failed to fetch active event: ${res.status}`); });
          }
          return res.json();
        })
        .then((eventData: ChatEvent) => {
          setCurrentEvent(eventData);
        })
        .catch((err: Error) => console.error("Error fetching active event:", err));
    }
  }, [authStatus]);


  // --- Subscribe to Real-time Data from Zero using useQuery ---
  // Subscribe to all messages. `z` might be null initially.
  // `useQuery` handles the null `z` gracefully (query is paused).
  const [rawMessagesData, messagesResult] = useQuery(z?.query.messages);
  // Subscribe to all users.
  const [rawUsersData, usersResult] = useQuery(z?.query.users);

  // Determine if the data from queries is complete (initial sync finished)
  const isMessagesDataComplete = messagesResult?.type === 'complete';
  const isUsersDataComplete = usersResult?.type === 'complete';


  // --- Process and Combine Data for Display ---
  const combinedMessages = useMemo((): MessageForUI[] => {
    // Guard against null/undefined data or missing event ID
    if (!currentEvent?.id || !rawMessagesData || !rawUsersData) return [];

    // Cast raw data to expected record types
    const messagesRecord = rawMessagesData as RawZeroMessage[] | null;
    const usersRecord = rawUsersData as RawZeroUser[] | null;

    if (!messagesRecord || !usersRecord) return [];

    // Filter messages for the current event and sort them
    const messagesForCurrentEvent = Object.values(messagesRecord)
      .filter((msg) => msg.eventId === currentEvent.id && !msg.isDeleted) // Filter out deleted messages for UI
      .sort((a, b) => a.createdAt - b.createdAt); // Sort by timestamp

    // Create a map of users for efficient lookup
    const usersMap = new Map<string, RawZeroUser>(
      Object.values(usersRecord).map(user => [user.id, user])
    );

    // Map raw messages to the UI message type, enriching with username
    return messagesForCurrentEvent.map((msg): MessageForUI => {
      const user = usersMap.get(msg.userId);
      return {
        ...msg,
        // Use user's username, or 'name' as displayName if available, fallback to 'Unknown User'
        username: user?.username || user?.name || 'Unknown User',
      };
    });

  }, [rawMessagesData, rawUsersData, currentEvent?.id]); // Recompute when data or event changes


  // --- Auto-scroll to bottom of messages ---
  useEffect(() => {
    if (messagesEndRef.current) {
      messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [combinedMessages]); // Scroll when new messages are added


  // --- Handle Sending New Message ---
  const handleSendMessage = async (e: React.FormEvent) => {
    e.preventDefault();
    // Ensure Zero instance is ready, data is synced, not already sending, text exists, and current event is set
    if (!z || !(isMessagesDataComplete && isUsersDataComplete) || isSending || !newMessageText.trim() || !currentEvent?.id) {
      console.warn("Cannot send message: Conditions not met.", {
        z_exists: !!z,
        dataComplete: isMessagesDataComplete && isUsersDataComplete,
        isSending,
        text: newMessageText,
        event: currentEvent
      });
      return;
    }

    const text = newMessageText.trim();
    if (!text) {
      console.warn("Attempted to send empty message.");
      return;
    }

    setIsSending(true);

    try {
      // Call the 'addMessage' mutator via the typed `z.mutate` object
      const mutation = z.mutate.addMessage({
        text: text || 'A',
        replyToId: replyToId === null ? undefined : replyToId, // Convert null to undefined
        eventId: currentEvent.id, // Pass current event ID for server-side association
      });
      await mutation.server; // Await the mutation to ensure it completes
      console.log("addMessage mutation sent successfully.");
      setNewMessageText(''); // Clear input on successful optimistic update
      setReplyToId(null);   // Clear reply state
    } catch (err: any) { // Catch errors from the mutator call (client-side or server-side)
      console.error("Error sending message mutation:", err);
      alert(`Failed to send message: ${err.message}`); // Display error to the user
    } finally {
      setIsSending(false);
    }
  };

  // --- Handle Clicking on a Message to Reply ---
  const handleReplyClick = (messageId: string, username: string) => {
    setReplyToId(messageId);
    setNewMessageText(`@${username} `); // Pre-fill input
    const inputElement = document.getElementById('messageInput');
    if (inputElement) inputElement.focus(); // Focus the input field
  };


  // --- Render Loading and Error States ---
  if (authStatus === 'loading') return <LinesLoader />; // Authentication loading
  if (!session) return <div>Please sign in to join the chat.</div>; // Not authenticated
  if (!isZeroInstanceReady) return <LinesLoader />; // Zero client instance not yet initialized
  if (!currentEvent) return <LinesLoader />; // Loading active event details
  // Show "Syncing..." if initial data load from Zero isn't complete
  if (!isMessagesDataComplete || !isUsersDataComplete) return <LinesLoader />;


  // --- Render Chat UI ---
  return (
    <div className="flex flex-col h-screen bg-gray-50 dark:bg-gray-900">
      <header className="bg-white dark:bg-gray-800 shadow-sm text-gray-800 dark:text-white p-4 flex justify-between items-center">
        <h1 className="text-xl font-semibold">Chat: {currentEvent.name || 'Live Event'}</h1>
        <span className={`text-xs px-2 py-1 rounded-full ${isMessagesDataComplete && isUsersDataComplete ? 'bg-green-100 text-green-700' : 'bg-yellow-100 text-yellow-700'}`}>
          {isMessagesDataComplete && isUsersDataComplete ? 'Synced' : 'Syncing...'}
        </span>
      </header>

      <div className="flex-1 overflow-y-auto p-4 space-y-4">
        {combinedMessages.length === 0 && (
          <div className="text-center text-gray-500 dark:text-gray-400 pt-10">
            No messages yet. Be the first to say something!
          </div>
        )}
        {combinedMessages.map((message) => (
          <div key={message.id} className={`flex items-start space-x-3 p-3 rounded-lg ${message.isDeleted ? 'opacity-60 italic bg-red-50 dark:bg-red-900/30' : 'bg-white dark:bg-gray-800 shadow-sm'}`}>
            {/* Optional User Avatar based on message.userId and usersMap */}
            {/* <UserAvatar userId={message.userId} usersMap={usersMap} /> */}
            <div className="flex-1">
              <div className="flex items-center space-x-2">
                <span className="font-semibold text-sm text-blue-600 dark:text-blue-400">{message.username}</span>
                <span className="text-xs text-gray-500 dark:text-gray-400">
                  {new Date(message.createdAt).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                </span>
                {message.isDeleted && <span className="text-xs text-red-600 dark:text-red-400">(Deleted)</span>}
              </div>
              {message.replyToMessageId && (
                <div className="mt-1 text-xs text-gray-500 dark:text-gray-400 border-l-2 border-gray-300 dark:border-gray-600 pl-2 mb-1">
                  Replying to: <span className="italic">"{combinedMessages.find(m => m.id === message.replyToMessageId)?.text.substring(0, 30) || 'original message'}{combinedMessages.find(m => m.id === message.replyToMessageId)?.text && combinedMessages.find(m => m.id === message.replyToMessageId)!.text.length > 30 ? '...' : ''}"</span>
                </div>
              )}
              <p className="text-gray-800 dark:text-gray-200 mt-1">{message.text}</p>
              {!message.isDeleted && (
                <button
                  onClick={() => handleReplyClick(message.id, message.username || 'User')}
                  className="text-xs text-blue-500 hover:underline mt-2"
                >
                  Reply
                </button>
              )}
              {(session.user as CustomUser)?.role === 'admin' && !message.isDeleted && (
                <button
                  onClick={() => {
                    if (z) { // z is the Zero instance
                      z.mutate.deleteMessage({ messageId: message.id })
                    }
                  }}
                  className="text-xs text-red-500 hover:underline ml-3 mt-2"
                >
                  Delete (Admin)
                </button>
              )}
            </div>
          </div>
        ))}
        <div ref={messagesEndRef} /> {/* Anchor for auto-scrolling */}
      </div>

      {/* Message Input Area */}
      <div className="p-4 bg-gray-100 dark:bg-gray-800 border-t border-gray-200 dark:border-gray-700">
        {replyToId && (
          <div className="text-sm text-gray-700 dark:text-gray-300 mb-2 flex justify-between items-center">
            <span>
              Replying to: <span className="italic">"{combinedMessages.find(m => m.id === replyToId)?.text.substring(0, 40) || '...'}{combinedMessages.find(m => m.id === replyToId)?.text && combinedMessages.find(m => m.id === replyToId)!.text.length > 40 ? '...' : ''}"</span>
            </span>
            <button onClick={() => { setReplyToId(null); setNewMessageText(''); }} className="text-red-500 text-xs ml-2 hover:underline">Cancel</button>
          </div>
        )}
        <form onSubmit={handleSendMessage} className="flex space-x-3">
          <input
            id="messageInput"
            type="text"
            value={newMessageText}
            onChange={(e) => setNewMessageText(e.target.value)}
            placeholder="Type a message..."
            className="flex-1 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm p-2 bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:ring-blue-500 focus:border-blue-500 disabled:opacity-50"
            disabled={!(isMessagesDataComplete && isUsersDataComplete) || isSending || !currentEvent?.id}
          />
          <button
            type="submit"
            disabled={!(isMessagesDataComplete && isUsersDataComplete) || isSending || !newMessageText.trim() || !currentEvent?.id}
            className="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-md disabled:opacity-50 disabled:bg-gray-400"
          >
            {isSending ? 'Sending...' : 'Send'}
          </button>
        </form>
      </div>
    </div>
  );
}